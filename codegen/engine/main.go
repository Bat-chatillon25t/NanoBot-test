package main

import (
	"os"
	"strings"

	"gopkg.in/yaml.v3"
)

const head = `// Code generated by codegen/engine. DO NOT EDIT.

package nano
`

const emptyon = `
// On[Message] ...
func (e *Engine) On[Message](rules ...Rule) *Matcher { return e.On("[Message]", rules...) }

// On[Message] ...
func On[Message](rules ...Rule) *Matcher { return On("[Message]", rules...) }
`

const ruleon = `
// On[Message][Rule] ...
func On[Message][Rule]([Name] [Type], rules ...Rule) *Matcher {
	return defaultEngine.On[Message][Rule]([Name], rules...)
}

// On[Message][Rule] ...
func (e *Engine) On[Message][Rule]([Name] [Type], rules ...Rule) *Matcher {
	matcher := &Matcher{
		Type:   "[Message]",
		Rules:  append([]Rule{[Rule]Rule([Name][...])}, rules...),
		Engine: e,
	}
	e.matchers = append(e.matchers, matcher)
	return StoreMatcher(matcher)
}
`

const ruleonshell = `
// On[Message]Shell shell命令触发器
func On[Message]Shell(command string, model interface{}, rules ...Rule) *Matcher {
	return defaultEngine.On[Message]Shell(command, model, rules...)
}

// On[Message]Shell shell命令触发器
func (e *Engine) On[Message]Shell(command string, model interface{}, rules ...Rule) *Matcher {
	matcher := &Matcher{
		Type:   "[Message]",
		Rules:  append([]Rule{ShellRule(command, model)}, rules...),
		Engine: e,
	}
	e.matchers = append(e.matchers, matcher)
	return StoreMatcher(matcher)
}
`

type config struct {
	EmptyOn []string `yaml:"emptyon"`
	RuleOn  struct {
		Message []string             `yaml:"Message"`
		Rule    map[string][2]string `yaml:"Rule"`
	} `yaml:"ruleon"`
}

func main() {
	f, err := os.Create("engine_generated.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	_, err = f.WriteString(head)
	if err != nil {
		panic(err)
	}
	ef, err := os.Open("codegen/engine/engine.yml")
	if err != nil {
		panic(err)
	}
	defer ef.Close()
	cfg := config{}
	err = yaml.NewDecoder(ef).Decode(&cfg)
	if err != nil {
		panic(err)
	}
	for _, msg := range cfg.EmptyOn {
		_, err = f.WriteString(strings.ReplaceAll(emptyon, "[Message]", msg))
		if err != nil {
			panic(err)
		}
	}
	for _, msg := range cfg.RuleOn.Message {
		for rule, x := range cfg.RuleOn.Rule {
			s := strings.ReplaceAll(ruleon, "[Message]", msg)
			s = strings.ReplaceAll(s, "[Rule]", rule)
			s = strings.ReplaceAll(s, "[Name]", x[0])
			s = strings.ReplaceAll(s, "[Type]", x[1])
			if strings.Contains(rule, "Group") {
				s = strings.ReplaceAll(s, "[...]", "...")
			} else {
				s = strings.ReplaceAll(s, "[...]", "")
			}
			_, err = f.WriteString(s)
			if err != nil {
				panic(err)
			}
		}
		_, err = f.WriteString(strings.ReplaceAll(ruleonshell, "[Message]", msg))
		if err != nil {
			panic(err)
		}
	}
}
